#  Copyright 2023 Google LLC
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Autogeneration of stub Jupyter notebooks."""

import inspect
from pathlib import Path
from types import ModuleType
from typing import List, Tuple

import nbformat

_IMPORTS = """\
from qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register
from qualtran import QBit, QInt, QUInt, QAny
from qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma
from typing import *
import numpy as np
import sympy
import cirq\
"""

_BLOQ_DISPLAY = """\
{lines}
bloq = {obj_expression}
show_bloq(bloq)\
"""


def _get_title_lines(title: str, mod: ModuleType) -> List[str]:
    """Return markdown lines for the title cell.

    This consists of the specified title as well as the associated module's docstring.
    """
    lines = [f'# {title}']

    if mod.__doc__ is None:
        return lines

    lines.append('')
    lines += inspect.cleandoc(mod.__doc__).splitlines()
    return lines


_K_CQ_AUTOGEN = 'cq.autogen'
"""The jupyter metadata key we use to identify cells we've autogenerated.

We use the letters "cq" for historical reasons.
"""


def _md_nbnode(source: str, cqid: str) -> nbformat.NotebookNode:
    """Helper function to return a markdown cell with correct metadata"""
    return nbformat.v4.new_markdown_cell(source, metadata={_K_CQ_AUTOGEN: cqid})


def _code_nbnode(source: str, cqid: str) -> nbformat.NotebookNode:
    """Helper function to return a code cell with correct metadata"""
    return nbformat.v4.new_code_cell(source, metadata={_K_CQ_AUTOGEN: cqid})


def _init_notebook(
    path_stem: str, overwrite=False, directory: str = '.'
) -> Tuple[nbformat.NotebookNode, Path]:
    """Initialize a jupyter notebook.

    If one already exists: load it in. Otherwise, create a new one.

    Args:
        path_stem: The extensionless filename to find the notebook if it exists.
        overwrite: If set, remove any existing notebook and start from scratch.
        directory: The directory in which we look for the filename.
    """

    nb_path = Path(f'{directory}') / f'{path_stem}.ipynb'

    if overwrite:
        nb_path.unlink(missing_ok=True)

    if nb_path.exists():
        print(f'[{path_stem}] Loading existing: {nb_path}')
        with nb_path.open('r') as f:
            return nbformat.read(f, as_version=4), nb_path

    print(f'[{path_stem}] Creating new: {nb_path}')
    nb = nbformat.v4.new_notebook()
    nb['metadata'].update(
        {
            'kernelspec': {'language': 'python', 'name': 'python3', 'display_name': 'Python 3'},
            'language_info': {'name': 'python'},
        }
    )
    return nb, nb_path
